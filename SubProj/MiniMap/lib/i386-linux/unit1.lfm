object MainForm: TMainForm
  Left = 57
  Height = 427
  Top = 57
  Width = 829
  Caption = 'MainForm'
  ClientHeight = 404
  ClientWidth = 829
  Menu = MainMenu1
  OnCreate = FormCreate
  LCLVersion = '1.3'
  inline SynMemo: TSynMemo
    Cursor = crIBeam
    Left = 0
    Height = 404
    Top = 0
    Width = 659
    Align = alClient
    Font.Height = -13
    Font.Name = 'Courier New'
    Font.Pitch = fpFixed
    Font.Quality = fqNonAntialiased
    ParentColor = False
    ParentFont = False
    TabOrder = 0
    Gutter.Width = 65
    Gutter.MouseActions = <>
    Highlighter = SynFreePascalSyn1
    Keystrokes = <    
      item
        Command = ecUp
        ShortCut = 38
      end    
      item
        Command = ecSelUp
        ShortCut = 8230
      end    
      item
        Command = ecScrollUp
        ShortCut = 16422
      end    
      item
        Command = ecDown
        ShortCut = 40
      end    
      item
        Command = ecSelDown
        ShortCut = 8232
      end    
      item
        Command = ecScrollDown
        ShortCut = 16424
      end    
      item
        Command = ecLeft
        ShortCut = 37
      end    
      item
        Command = ecSelLeft
        ShortCut = 8229
      end    
      item
        Command = ecWordLeft
        ShortCut = 16421
      end    
      item
        Command = ecSelWordLeft
        ShortCut = 24613
      end    
      item
        Command = ecRight
        ShortCut = 39
      end    
      item
        Command = ecSelRight
        ShortCut = 8231
      end    
      item
        Command = ecWordRight
        ShortCut = 16423
      end    
      item
        Command = ecSelWordRight
        ShortCut = 24615
      end    
      item
        Command = ecPageDown
        ShortCut = 34
      end    
      item
        Command = ecSelPageDown
        ShortCut = 8226
      end    
      item
        Command = ecPageBottom
        ShortCut = 16418
      end    
      item
        Command = ecSelPageBottom
        ShortCut = 24610
      end    
      item
        Command = ecPageUp
        ShortCut = 33
      end    
      item
        Command = ecSelPageUp
        ShortCut = 8225
      end    
      item
        Command = ecPageTop
        ShortCut = 16417
      end    
      item
        Command = ecSelPageTop
        ShortCut = 24609
      end    
      item
        Command = ecLineStart
        ShortCut = 36
      end    
      item
        Command = ecSelLineStart
        ShortCut = 8228
      end    
      item
        Command = ecEditorTop
        ShortCut = 16420
      end    
      item
        Command = ecSelEditorTop
        ShortCut = 24612
      end    
      item
        Command = ecLineEnd
        ShortCut = 35
      end    
      item
        Command = ecSelLineEnd
        ShortCut = 8227
      end    
      item
        Command = ecEditorBottom
        ShortCut = 16419
      end    
      item
        Command = ecSelEditorBottom
        ShortCut = 24611
      end    
      item
        Command = ecToggleMode
        ShortCut = 45
      end    
      item
        Command = ecCopy
        ShortCut = 16429
      end    
      item
        Command = ecPaste
        ShortCut = 8237
      end    
      item
        Command = ecDeleteChar
        ShortCut = 46
      end    
      item
        Command = ecCut
        ShortCut = 8238
      end    
      item
        Command = ecDeleteLastChar
        ShortCut = 8
      end    
      item
        Command = ecDeleteLastChar
        ShortCut = 8200
      end    
      item
        Command = ecDeleteLastWord
        ShortCut = 16392
      end    
      item
        Command = ecUndo
        ShortCut = 32776
      end    
      item
        Command = ecRedo
        ShortCut = 40968
      end    
      item
        Command = ecLineBreak
        ShortCut = 13
      end    
      item
        Command = ecSelectAll
        ShortCut = 16449
      end    
      item
        Command = ecCopy
        ShortCut = 16451
      end    
      item
        Command = ecBlockIndent
        ShortCut = 24649
      end    
      item
        Command = ecLineBreak
        ShortCut = 16461
      end    
      item
        Command = ecInsertLine
        ShortCut = 16462
      end    
      item
        Command = ecDeleteWord
        ShortCut = 16468
      end    
      item
        Command = ecBlockUnindent
        ShortCut = 24661
      end    
      item
        Command = ecPaste
        ShortCut = 16470
      end    
      item
        Command = ecCut
        ShortCut = 16472
      end    
      item
        Command = ecDeleteLine
        ShortCut = 16473
      end    
      item
        Command = ecDeleteEOL
        ShortCut = 24665
      end    
      item
        Command = ecUndo
        ShortCut = 16474
      end    
      item
        Command = ecRedo
        ShortCut = 24666
      end    
      item
        Command = ecGotoMarker0
        ShortCut = 16432
      end    
      item
        Command = ecGotoMarker1
        ShortCut = 16433
      end    
      item
        Command = ecGotoMarker2
        ShortCut = 16434
      end    
      item
        Command = ecGotoMarker3
        ShortCut = 16435
      end    
      item
        Command = ecGotoMarker4
        ShortCut = 16436
      end    
      item
        Command = ecGotoMarker5
        ShortCut = 16437
      end    
      item
        Command = ecGotoMarker6
        ShortCut = 16438
      end    
      item
        Command = ecGotoMarker7
        ShortCut = 16439
      end    
      item
        Command = ecGotoMarker8
        ShortCut = 16440
      end    
      item
        Command = ecGotoMarker9
        ShortCut = 16441
      end    
      item
        Command = ecSetMarker0
        ShortCut = 24624
      end    
      item
        Command = ecSetMarker1
        ShortCut = 24625
      end    
      item
        Command = ecSetMarker2
        ShortCut = 24626
      end    
      item
        Command = ecSetMarker3
        ShortCut = 24627
      end    
      item
        Command = ecSetMarker4
        ShortCut = 24628
      end    
      item
        Command = ecSetMarker5
        ShortCut = 24629
      end    
      item
        Command = ecSetMarker6
        ShortCut = 24630
      end    
      item
        Command = ecSetMarker7
        ShortCut = 24631
      end    
      item
        Command = ecSetMarker8
        ShortCut = 24632
      end    
      item
        Command = ecSetMarker9
        ShortCut = 24633
      end    
      item
        Command = EcFoldLevel1
        ShortCut = 41009
      end    
      item
        Command = EcFoldLevel2
        ShortCut = 41010
      end    
      item
        Command = EcFoldLevel3
        ShortCut = 41011
      end    
      item
        Command = EcFoldLevel4
        ShortCut = 41012
      end    
      item
        Command = EcFoldLevel5
        ShortCut = 41013
      end    
      item
        Command = EcFoldLevel6
        ShortCut = 41014
      end    
      item
        Command = EcFoldLevel7
        ShortCut = 41015
      end    
      item
        Command = EcFoldLevel8
        ShortCut = 41016
      end    
      item
        Command = EcFoldLevel9
        ShortCut = 41017
      end    
      item
        Command = EcFoldLevel0
        ShortCut = 41008
      end    
      item
        Command = EcFoldCurrent
        ShortCut = 41005
      end    
      item
        Command = EcUnFoldCurrent
        ShortCut = 41003
      end    
      item
        Command = EcToggleMarkupWord
        ShortCut = 32845
      end    
      item
        Command = ecNormalSelect
        ShortCut = 24654
      end    
      item
        Command = ecColumnSelect
        ShortCut = 24643
      end    
      item
        Command = ecLineSelect
        ShortCut = 24652
      end    
      item
        Command = ecTab
        ShortCut = 9
      end    
      item
        Command = ecShiftTab
        ShortCut = 8201
      end    
      item
        Command = ecMatchBracket
        ShortCut = 24642
      end    
      item
        Command = ecColSelUp
        ShortCut = 40998
      end    
      item
        Command = ecColSelDown
        ShortCut = 41000
      end    
      item
        Command = ecColSelLeft
        ShortCut = 40997
      end    
      item
        Command = ecColSelRight
        ShortCut = 40999
      end    
      item
        Command = ecColSelPageDown
        ShortCut = 40994
      end    
      item
        Command = ecColSelPageBottom
        ShortCut = 57378
      end    
      item
        Command = ecColSelPageUp
        ShortCut = 40993
      end    
      item
        Command = ecColSelPageTop
        ShortCut = 57377
      end    
      item
        Command = ecColSelLineStart
        ShortCut = 40996
      end    
      item
        Command = ecColSelLineEnd
        ShortCut = 40995
      end    
      item
        Command = ecColSelEditorTop
        ShortCut = 57380
      end    
      item
        Command = ecColSelEditorBottom
        ShortCut = 57379
      end>
    MouseActions = <>
    MouseSelActions = <>
    Lines.Strings = (
      '(*******************************************************************************'
      '  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~'
      '/    Contributors(alphabetical order):    /'
      '~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~'
      ''
      '  Dorin Duminica - http://www.delphigeist.com'
      ''
      '~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~'
      ''
      '  Change Log:'
      ''
      ' ~~~~~~~~~~~~~~~~'
      '/    v 1.1     /'
      '~~~~~~~~~~~~~~~'
      ''
      '    new:'
      '    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~'
      '    -'#9'editor scroll from MiniMap'
      '    -'#9'options class(to be extended)'
      '    -'#9'published a few more properties'
      ''
      '    fixes:'
      '    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~'
      '    -'#9'fixed flickering on scroll'
      '    -'#9'fixed line number calculation on click'
      ''
      '    other:'
      '    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~'
      '    -'#9'cleanups'
      ''
      '    known issues:'
      '    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~'
      '    -'#9'translation of "char" when clicking the map is'
      '      not always correct needs rewrite'
      ''
      ' ~~~~~~~~~~~~~~~'
      '/    v 1.0    /'
      '~~~~~~~~~~~~~~'
      ''
      '    -'#9'initial release'
      ''
      '*******************************************************************************)'
      'unit SynMiniMap;'
      ''
      '{$MODE Delphi}'
      ''
      'interface'
      ''
      'uses'
      '   SysUtils'
      '  ,LCLIntf, LCLType, LMessages'
      '  ,Classes'
      '  ,Controls'
      '  ,Graphics'
      ''
      '  ,SynEdit, SynEditPlugins'
      '  ;'
      ''
      'const'
      '  SYNMINIMAP_DEFAULT_HEIGHT = 400;'
      '  SYNMINIMAP_DEFAULT_WIDTH = 200;'
      '  SYNMINIMAP_DEFAULT_FONTFACTOR = 3;'
      '  SYNMINIMAP_FONTFACTOR_MIN = 2;'
      '  SYNMINIMAP_FONTFACTOR_MAX = 4;'
      '  SYNMINIMAP_DEFAULT_OPTIONS_TABWIDTH = 4;'
      ''
      'type'
      '  PPoint = ^TPoint;'
      ''
      'type'
      '  TSynMiniMapCanvasHelper = class Helper for TCanvas'
      '  public'
      '    procedure StretchDrawHalftone(const AX, AY, AWidth, AHeight: Integer;'
      '      const ASource: TCanvas;'
      '      const ASrcX, ASrcY, ASrcWidth, ASrcHeight: Integer); overload;'
      '    procedure StretchDrawHalftone(const APoint: TPoint;'
      '      const AWidth, AHeight: Integer; const ASource: TCanvas;'
      '      const ASrcPoint: TPoint; ASrcWidth, ASrcHeight: Integer); overload;'
      '  end;'
      ''
      'type'
      '  ///'
      '  ///  don''t modify this, it will be extended to pass other information'
      '  ///  in the future without breaking backwards compatibility'
      '  ///'
      '  PSynMiniMapEventData = ^TSynMiniMapEventData;'
      '  TBufferCoord = record'
      '    Char: Integer;'
      '    Line: Integer;'
      #9'end;'
      ''
      '  TSynMiniMapEventData = record'
      '    Coord: TBufferCoord;'
      '    Redraw: Boolean;'
      '  end;'
      ''
      'const'
      '  szSynMiniMapEventData = SizeOf(TSynMiniMapEventData);'
      ''
      'type'
      '  ///'
      '  ///  colors for mini map'
      '  ///'
      '  TSynMiniMapColors = class(TPersistent)'
      '  private'
      '    FBackground: TColor;'
      '    FHighlight: TColor;'
      '    FPreviousLine: TColor;'
      '    FPreviousLineText: TColor;'
      '    FText: TColor;'
      '    FTextHighlight: TColor;'
      '  public'
      '    constructor Create(AOwner: TComponent);'
      '  published'
      '    property Background: TColor read FBackground write FBackground;'
      '    property Highlight: TColor read FHighlight write FHighlight;'
      '    property PreviousLine: TColor read FPreviousLine write FPreviousLine;'
      '    property PreviousLineText: TColor read FPreviousLineText write FPreviousLineText;'
      '    property Text: TColor read FText write FText;'
      '    property TextHighlight: TColor read FTextHighlight write FTextHighlight;'
      '  end;'
      ''
      '  ///'
      '  ///  various behavioral options'
      '  ///'
      '  TSynMinimapOptions = class(TPersistent)'
      '  private'
      '    FAllowScroll: Boolean;'
      '    FReverseScroll: Boolean;'
      '    FTabWidthOverride: Boolean;'
      '    FTabWidth: Integer;'
      '  public'
      '    constructor Create(AOwner: TComponent);'
      '  published'
      '    ///'
      '    ///  scrolling editor using the MiniMap is possible only if AllowScroll'
      '    ///'
      '    property AllowScroll: Boolean read FAllowScroll write FAllowScroll;'
      '    property ReverseScroll: Boolean read FReverseScroll write FReverseScroll;'
      '    property TabWidthOverride: Boolean read FTabWidthOverride write FTabWidthOverride;'
      '    property TabWidth: Integer read FTabWidth write FTabWidth;'
      '  end;'
      ''
      '  ///'
      '  ///  event fired under various conditions'
      '  ///'
      '  TSynMiniMapEvent = procedure (Sender: TObject; Data: PSynMiniMapEventData) of Object;'
      ''
      ''
      '  ///'
      '  ///  forward declaration'
      '  ///'
      '  TSynMiniMap = class;'
      ''
      '  ///'
      '  ///  this plugin helps hook a few important events'
      '  ///'
      ''
      #9'{ TSynMiniMapEditorPlugin }'
      ''
      '  TSynMiniMapEditorPlugin = class(TLazSynEditPlugin)'
      '  protected'
      '    procedure BeforeEditorChange; override;'
      '    procedure AfterEditorChange; override;'
      '  {  procedure AfterPaint(ACanvas: TCanvas; const AClip: TRect;'
      '      FirstLine: Integer; LastLine: Integer); override;'
      '    procedure LinesDeleted(FirstLine: Integer; Count: Integer); override;'
      '    procedure LinesInserted(FirstLine: Integer; Count: Integer); override;}'
      '  private'
      '    FSynMiniMap: TSynMiniMap;'
      '  public'
      '    constructor Create(ASynMiniMap: TSynMiniMap);'
      '  end;'
      ''
      '  ///'
      '  ///  the minimap itself'
      '  ///'
      '  TSynMiniMap = class(TCustomControl)'
      '  protected'
      '    procedure Resize; override;'
      '    procedure Paint; override;'
      '    procedure MouseDown(Button: TMouseButton; Shift: TShiftState; X: Integer;'
      '      Y: Integer); override;'
      '    procedure MouseMove(Shift: TShiftState; X: Integer; Y: Integer); override;'
      '    procedure MouseUp(Button: TMouseButton; Shift: TShiftState; X: Integer;'
      '      Y: Integer); override;'
      '    procedure DoClick(const AX, AY: Integer); virtual;'
      '  private'
      '    FFullSizeBitmap: TBitmap;'
      '    FOffsetBitmap: TBitmap;'
      '    FEditor: TSynEdit;'
      '  private'
      '    FEditorHeight: Integer;'
      '    FEditorWidth: Integer;'
      '    FEditorRealWidth: Integer;'
      '    FFirstLine: Integer;'
      '    FLastLine: Integer;'
      '    FMaxCharsPerLine: Word;'
      '    FLineHeightInPixels: Integer;'
      '    FPreviousLineIndex: Integer;'
      '    FFontFactor: Single;'
      '    FCharWidth: Integer;'
      '    FTabWidth: Integer;'
      '    FOptions: TSynMinimapOptions;'
      '    ///'
      '    ///  mouse down & move => scroll'
      '    ///  mouse down + up => click'
      '    ///'
      '    FMouseDownPoint: TPoint;'
      '    FMouseUpPoint: TPoint;'
      '    FScrolling: Boolean;'
      '  private'
      '    FOnClick: TSynMiniMapEvent;'
      '  private'
      '    FColors: TSynMiniMapColors;'
      '    FMiniMapPlugin: TSynMiniMapEditorPlugin;'
      '  private'
      '    function GetClickCoord: TBufferCoord;'
      '    procedure ClearEventData(var AEventData: TSynMiniMapEventData); inline;'
      '    procedure Render; virtual;'
      '  private'
      '    function GetPixelFormat: TPixelFormat;'
      '    procedure SetPixelFormat(const Value: TPixelFormat);'
      '    procedure SetEditor(const Value: TSynEdit);'
      '    procedure SetFontFactor(const Value: Single);'
      '  public'
      '    constructor Create(AOwner: TComponent); override;'
      '    destructor Destroy; override;'
      '    procedure ResetInternals;'
      '  public'
      '    function TranslatePoint(const APoint: PPoint): TBufferCoord;'
      '  public'
      '    property PreviousLineIndex: Integer read FPreviousLineIndex;'
      '    property Scrolling: Boolean read FScrolling;'
      '  published'
      '    property Colors: TSynMiniMapColors read FColors write FColors;'
      '    property Editor: TSynEdit read FEditor write SetEditor;'
      '    property FontFactor: Single read FFontFactor write SetFontFactor;'
      '    property Options: TSynMinimapOptions read FOptions write FOptions;'
      '    property PixelFormat: TPixelFormat read GetPixelFormat write SetPixelFormat;'
      '  published'
      '    property OnClick: TSynMiniMapEvent read FOnClick write FOnClick;'
      '  published'
      '    property Align;'
      '    //property AlignWithMargins;'
      '    property Constraints;'
      '    property Height;'
      '    property ShowHint;'
      '    property Width;'
      '    property OnDblClick;'
      '    property OnResize;'
      '  end;'
      ''
      'procedure Register;'
      ''
      'implementation'
      ''
      'uses'
      '  Math'
      '  ,Dialogs'
      '  ;'
      ''
      'resourcestring'
      '  SFontFactorMinMax = ''Font factor cannot be smaller than %.d or greater than %.d.'';'
      ''
      'procedure Register;'
      'begin'
      '  RegisterComponents(''SynEdit'', [TSynMiniMap]);'
      'end;'
      ''
      '{ TSynMiniMapCanvasHelper }'
      ''
      'procedure TSynMiniMapCanvasHelper.StretchDrawHalftone(const AX, AY, AWidth,'
      '  AHeight: Integer; const ASource: TCanvas;'
      '  const ASrcX, ASrcY, ASrcWidth, ASrcHeight: Integer);'
      'begin'
      '  ///'
      '  ///  helper function for stretch draw of full size bitmap on to'
      '  ///  a smaller one'
      '  ///'
      '  SetStretchBltMode(Self.Handle, HALFTONE);'
      '  StretchBlt('
      '    Self.Handle,'
      '    AX, AY,'
      '    AWidth, AHeight,'
      '    ASource.Handle,'
      '    ASrcX, ASrcY,'
      '    ASrcWidth, ASrcHeight,'
      '    SRCCOPY'
      '  );'
      'end;'
      ''
      'procedure TSynMiniMapCanvasHelper.StretchDrawHalftone(const APoint: TPoint;'
      '  const AWidth, AHeight: Integer; const ASource: TCanvas;'
      '  const ASrcPoint: TPoint; ASrcWidth, ASrcHeight: Integer);'
      'begin'
      '  StretchDrawHalftone('
      '    APoint.X, APoint.Y,'
      '    AWidth, AHeight,'
      '    ASource,'
      '    ASrcPoint.X, ASrcPoint.Y,'
      '    ASrcWidth, ASrcHeight);'
      'end;'
      ''
      '{ TSynMiniMapColors }'
      ''
      'constructor TSynMiniMapColors.Create(AOwner: TComponent);'
      'begin'
      '  inherited Create;'
      '  ///'
      '  ///  set default values'
      '  ///'
      '  Background := clWhite;'
      '  Highlight := $f4f4f4;'
      '  PreviousLine := clNone;'
      '  PreviousLineText := clNone;'
      '  Text := clGray;'
      '  TextHighlight := Text;'
      'end;'
      ''
      '{ TSynMinimapOptions }'
      ''
      'constructor TSynMinimapOptions.Create(AOwner: TComponent);'
      'begin'
      '  inherited Create;'
      '  AllowScroll := False;'
      '  ReverseScroll := False;'
      '  TabWidthOverride := False;'
      '  TabWidth := SYNMINIMAP_DEFAULT_OPTIONS_TABWIDTH;'
      'end;'
      ''
      '{ TSynMiniMapEditorPlugin }'
      '                                              {'
      'procedure TSynMiniMapEditorPlugin.AfterPaint(ACanvas: TCanvas;'
      '  const AClip: TRect; FirstLine, LastLine: Integer);'
      'begin'
      '  inherited;'
      '  FSynMiniMap.Render;'
      'end;       }'
      ''
      'procedure TSynMiniMapEditorPlugin.BeforeEditorChange;'
      'begin'
      #9#9'inherited BeforeEditorChange;'
      '    //FSynMiniMap.Render;'
      'end;'
      ''
      'procedure TSynMiniMapEditorPlugin.AfterEditorChange;'
      'begin'
      #9#9'inherited AfterEditorChange;'
      '    //FSynMiniMap.Render;'
      'end;'
      ''
      'constructor TSynMiniMapEditorPlugin.Create(ASynMiniMap: TSynMiniMap);'
      'begin'
      '  inherited Create(ASynMiniMap.Editor);'
      '  FSynMiniMap := ASynMiniMap;'
      'end;'
      '            {'
      'procedure TSynMiniMapEditorPlugin.LinesDeleted(FirstLine, Count: Integer);'
      'var'
      '  LLineIndex: Integer;'
      'begin'
      '  inherited;'
      '  ///'
      '  ///  check if we need to decrement the previous line index'
      '  ///  if current line index is 10 and the user deleted a few lines'
      '  ///  before that, we need to adjust FPreviousLineIndex'
      '  ///'
      '  LLineIndex := FirstLine -1;'
      '  if FSynMiniMap.PreviousLineIndex >= LLineIndex then begin'
      '    Dec(FSynMiniMap.FPreviousLineIndex, Count);'
      '    FSynMiniMap.Render;'
      '  end;'
      'end;'
      ''
      'procedure TSynMiniMapEditorPlugin.LinesInserted(FirstLine, Count: Integer);'
      'var'
      '  LLineIndex: Integer;'
      'begin'
      '  inherited;'
      '  ///'
      '  ///  check if we need to increment the previous line index'
      '  ///  if current line index is 10 and the user added a few lines'
      '  ///  before that, we need to adjust FPreviousLineIndex'
      '  ///'
      '  LLineIndex := FirstLine -1;'
      '  if FSynMiniMap.PreviousLineIndex >= LLineIndex then begin'
      '    Inc(FSynMiniMap.FPreviousLineIndex, Count );'
      '    FSynMiniMap.Render;'
      '  end;'
      'end;'
      ''
      '{ TSynMiniMap }'
      ''
      'procedure TSynMiniMap.ClearEventData(var AEventData: TSynMiniMapEventData);'
      'begin'
      '  FillChar(AEventData, 0, szSynMiniMapEventData);'
      'end;'
      ''
      'constructor TSynMiniMap.Create(AOwner: TComponent);'
      'begin'
      '  inherited;'
      '  FFullSizeBitmap := TBitmap.Create;'
      '  FOffsetBitmap := TBitmap.Create;'
      '  FColors := TSynMiniMapColors.Create(Self);'
      '  PixelFormat := pf32bit;'
      '  Self.Height := SYNMINIMAP_DEFAULT_HEIGHT;'
      '  Self.Width := SYNMINIMAP_DEFAULT_WIDTH;'
      '  FMaxCharsPerLine := 100;'
      '  FOptions := TSynMinimapOptions.Create(Self);'
      '  FPreviousLineIndex := -1;'
      '  FFontFactor := SYNMINIMAP_DEFAULT_FONTFACTOR;'
      '  FScrolling := False;'
      'end;'
      ''
      'destructor TSynMiniMap.Destroy;'
      'begin'
      '  FColors.Free;'
      '  FFullSizeBitmap.Free;'
      '  FOffsetBitmap.Free;'
      '  FOptions.Free;'
      '  inherited;'
      'end;'
      ''
      'procedure TSynMiniMap.DoClick(const AX, AY: Integer);'
      'var'
      '  LEventData: TSynMiniMapEventData;'
      '  LPoint: TPoint;'
      'begin'
      '  ///'
      '  ///  OnClick has no value unless we have an editor assign'
      '  ///'
      '  if Assigned(FOnClick) and Assigned(FEditor) then begin'
      '    ///'
      '    ///  save previous line index for drawing in Render'
      '    ///'
      '    FPreviousLineIndex := FEditor.CaretY -1;'
      '    ///'
      '    ///  reset event data record'
      '    ///'
      '    ClearEventData(LEventData);'
      '    ///'
      '    ///  set the Line and Char coordonates'
      '    ///'
      '    LPoint.X := AX;'
      '    LPoint.Y := AY;'
      '    LEventData.Coord := TranslatePoint(@LPoint);'
      '    ///'
      '    ///  invoke assigned event'
      '    ///'
      '    FOnClick(Self, @LEventData);'
      '    ///'
      '    ///  check if we were asked to redraw'
      '    ///'
      '    if LEventData.Redraw then'
      '      Render;'
      '  end;'
      'end;'
      ''
      'function TSynMiniMap.GetClickCoord: TBufferCoord;'
      'var'
      '  LPoint: TPoint;'
      'begin'
      '  ///'
      '  ///  grab the cursor coordonates'
      '  ///'
      '  GetCursorPos(LPoint);'
      '  LPoint := Self.ScreenToClient(LPoint);'
      '  Result := TranslatePoint(@LPoint);'
      'end;'
      ''
      'function TSynMiniMap.GetPixelFormat: TPixelFormat;'
      'begin'
      '  ///'
      '  ///  return the current pixel format'
      '  ///'
      '  Result := FFullSizeBitmap.PixelFormat;'
      'end;'
      ''
      'procedure TSynMiniMap.MouseDown(Button: TMouseButton; Shift: TShiftState; X,'
      '  Y: Integer);'
      'begin'
      '  inherited;'
      '  FScrolling := ( mbLeft = Button ) and Options.AllowScroll;'
      '  FMouseDownPoint.X := X;'
      '  FMouseDownPoint.Y := Y;'
      'end;'
      ''
      'procedure TSynMiniMap.MouseMove(Shift: TShiftState; X, Y: Integer);'
      'var'
      '  LDelta: Integer;'
      '  LScrollDown: Boolean;'
      'begin'
      '  inherited;'
      '  if NOT Options.AllowScroll then'
      '    Exit;'
      '  if Scrolling and Assigned(Editor) then begin'
      '    LDelta := FMouseDownPoint.Y - Y;'
      '    LDelta := Trunc(LDelta /  FFontFactor);'
      '    LDelta := Abs(LDelta);'
      ''
      '    LScrollDown := (Y > FMouseDownPoint.Y);'
      '    if Options.ReverseScroll then'
      '      LScrollDown := NOT LScrollDown;'
      ''
      '    if LScrollDown then'
      '    //if Y > FMouseDownPoint.Y then'
      '      Editor.CaretY := Editor.CaretY + LDelta'
      '    else'
      '      Editor.CaretY := Editor.CaretY - LDelta;'
      '  end;'
      'end;'
      ''
      'procedure TSynMiniMap.MouseUp(Button: TMouseButton; Shift: TShiftState; X,'
      '  Y: Integer);'
      'var'
      '  LIsClick: Boolean;'
      'begin'
      '  inherited;'
      '  FScrolling := False;'
      '  FMouseUpPoint.X := X;'
      '  FMouseUpPoint.Y := Y;'
      '  LIsClick := ( NOT Options.AllowScroll )'
      '    or (( FMouseDownPoint.X = FMouseUpPoint.X)'
      '    and (FMouseDownPoint.Y = FMouseUpPoint.Y ));'
      '  if LIsClick then'
      '    DoClick(X, Y);'
      'end;'
      ''
      'procedure TSynMiniMap.Paint;'
      'begin'
      '  ///'
      '  ///  draw the buffered bitmap'
      '  ///'
      '  Canvas.Draw(0, 0, FOffsetBitmap);'
      'end;'
      ''
      'procedure TSynMiniMap.Render;'
      'var'
      '  LLineHeight: Integer;'
      '  LLineCount: Integer;'
      '  LLineTop: Integer;'
      '  LLineText: string;'
      '  LMaxLineCount: Integer;'
      '  LDrawHeight: Integer;'
      '  LDrawWidth: Integer;'
      '  LTopLineIndex: Integer;'
      '  LFocusRect: TRect;'
      '  LFocusTopIndex: Integer;'
      '  LPreviousLine: Boolean;'
      '  Index: Integer;'
      ''
      '    function __get_line_xpos: Integer;'
      '    ///'
      '    ///  this function is counting leading spaces and tabs'
      '    ///  could use improvements'
      '    ///'
      '    var'
      '      cIndex: Integer;'
      '    begin'
      '      Result := 0;'
      '      for cIndex := 1 to Length(LLineText) do'
      '        case LLineText[cIndex] of'
      '          #$9: Inc(Result, FTabWidth);'
      '          '' '': Inc(Result, FCharWidth);'
      '          else'
      '            Break;'
      '        end;'
      '    end;'
      ''
      'begin'
      '  if ( NOT Assigned(Editor) ) or ( csDestroying in ComponentState ) then'
      '    Exit;'
      ''
      '  ///'
      '  ///  this is where the magic happens'
      '  ///  what it does:'
      '  ///  -  the MiniMap control has a limited height, we need to translate'
      '  ///   that height into a maximum number of lines we can display from'
      '  ///   the synedit control'
      '  ///  -  create a "full size bitmap"'
      '  ///  -  paint various misc stuff(highlight, previous line, etc.)'
      '  ///  -  paint each line starting from X lines before current visible lines'
      '  ///   and Y lines after'
      '  ///  -  scale down the "full size bitmap" and paint it on to the'
      '  ///   "offset bitmap"'
      '  ///   each time the "pain event" occures, the "offset bitmap" is used to'
      '  ///   draw on the MiniMap control'
      '  ///'
      ''
      '  ///'
      '  ///  grab the lines'
      '  ///'
      '  LLineCount := Editor.Lines.Count;'
      '  ///'
      '  /// store the first visible line index'
      '  ///  IMPORTANT:'
      '  ///  -  synedit refers to lines as "real index" + 1'
      '  ///'
      '  LTopLineIndex := Editor.TopLine -1;'
      '  ///'
      '  ///  grab the font size of full size bitmap'
      '  ///'
      '  LLineHeight := FFullSizeBitmap.Canvas.Font.Size;'
      '  ///'
      '  ///  add a 2 pixel line spacing'
      '  ///'
      '  Inc(LLineHeight, 2);'
      '  ///'
      '  ///  "shrink" the font to a much small dimension, each character will be'
      '  ///  FontFactor times smaller than the "real thing"'
      '  ///'
      '  FLineHeightInPixels := Trunc( LLineHeight / FFontFactor);'
      '  ///'
      '  ///  calculate the maximum number of lines we can display'
      '  ///  IMPORTANT:'
      '  ///  -  FLineHeightInPixels includes the "line spacing"'
      '  ///'
      '  LMaxLineCount := Self.Height div FLineHeightInPixels;'
      '  ///'
      '  ///  calculate the smalles value of lines we will display'
      '  ///  if the lines in editor are more than we can display'
      '  ///  then we display the maximum possible, otherwise display as many'
      '  ///  as there are in the editor'
      '  ///'
      '  LLineCount := Min(LLineCount, LMaxLineCount);'
      '  ///'
      '  ///  setup the full size bitmap dimensions'
      '  ///'
      '  FFullSizeBitmap.Height := LLineCount * LLineHeight;'
      '  ///'
      '  ///  setup the background color and fill it'
      '  ///'
      '  FFullSizeBitmap.Canvas.Brush.Color := Colors.Background;'
      '  FFullSizeBitmap.Canvas.FillRect(Rect(0, 0, FFullSizeBitmap.Width, FFullSizeBitmap.Height));'
      '  ///'
      '  ///  calculate the first and last lines that we will grab from editor'
      '  ///  and display in the MiniMap'
      '  ///'
      '  FFirstLine := LTopLineIndex - ( LMaxLineCount div 2 ) + (Editor.LinesInWindow div 2);'
      '  FFirstLine := Max(FFirstLine, 0);'
      '  FLastLine := Min(FFirstLine + LLineCount, Editor.Lines.Count -1);'
      '  ///'
      '  ///  setup brush and pen'
      '  ///'
      '  FFullSizeBitmap.Canvas.Brush.Style := bsSolid;'
      '  FFullSizeBitmap.Canvas.Brush.Color := Colors.Highlight;'
      '  FFullSizeBitmap.Canvas.Pen.Style := psClear;'
      '  ///'
      '  ///  highlight visible lines with provided color'
      '  ///'
      '  LFocusTopIndex := LTopLineIndex - FFirstLine;'
      '  LFocusRect := Rect('
      '    0,'
      '    LFocusTopIndex * LLineHeight,'
      '    FFullSizeBitmap.Width,'
      '    ( LFocusTopIndex + Editor.LinesInWindow ) * LLineHeight'
      '  );'
      '  FFullSizeBitmap.Canvas.Rectangle(LFocusRect);'
      '  ///'
      '  ///  check if we need to hightlight previous line'
      '  ///  previous line is saved when the user clicks on the MiniMap'
      '  ///  on MiniMap''s OnClick event you can jump to the clicked line'
      '  ///'
      '  LPreviousLine := ( Colors.PreviousLine <> clNone ) and'
      '    ( PreviousLineIndex >= FFirstLine ) and ( PreviousLineIndex <= FLastLine );'
      '  if LPreviousLine then begin'
      '    FFullSizeBitmap.Canvas.Brush.Color := Colors.PreviousLine;'
      '    LFocusRect := Rect('
      '      0,'
      '      ( PreviousLineIndex - FFirstLine ) * LLineHeight,'
      '      FFullSizeBitmap.Width,'
      '      ( PreviousLineIndex - FFirstLine  + 1) * LLineHeight);'
      '    FFullSizeBitmap.Canvas.Rectangle(LFocusRect);'
      '  end;'
      '  ///'
      '  ///  set the brush style to clear, otherwise we get uggly background color'
      '  ///  for each line'
      '  ///'
      '  FFullSizeBitmap.Canvas.Brush.Style := bsClear;'
      '  ///'
      '  ///  LLineTop holds the Y pixel value of the line'
      '  ///'
      '  LLineTop := 0;'
      '  ///'
      '  ///  start drawing lines'
      '  ///'
      '  Index := FFirstLine;'
      '  while Index <= FLastLine do begin'
      '    ///'
      '    ///  grab current line text'
      '    ///'
      '    LLineText := Editor.Lines[Index];'
      '    if ( Index = PreviousLineIndex ) and (Colors.PreviousLineText <> clNone) then'
      '      ///'
      '      ///  color of the previous line if applies'
      '      ///'
      '      FFullSizeBitmap.Canvas.Font.Color := Colors.PreviousLineText'
      '    else'
      '    if ( Index >= LTopLineIndex ) and ( Index <= LTopLineIndex + Editor.LinesInWindow ) then'
      '      ///'
      '      ///  font color of lines visible in the editor'
      '      ///'
      '      FFullSizeBitmap.Canvas.Font.Color := Colors.TextHighlight'
      '    else'
      '      ///'
      '      ///  normal text font color'
      '      ///'
      '      FFullSizeBitmap.Canvas.Font.Color := Colors.Text;'
      '    ///'
      '    ///  draw the text'
      '    ///  at this point, the font size is the same as in the editor'
      '    ///  just the line spacing is smaller'
      '    ///'
      '    FFullSizeBitmap.Canvas.TextOut(__get_line_xpos, LLineTop, LLineText);'
      '    ///'
      '    ///  increment the top pixel'
      '    ///'
      '    Inc(LLineTop, LLineHeight);'
      '    ///'
      '    ///  increment the line'
      '    ///'
      '    Inc(Index);'
      '  end;'
      '  ///'
      '  ///  if the current number of lines in the editor is smaller than'
      '  ///  the maximum we can display, we need to fill the canvas with'
      '  ///  the provided background color'
      '  ///'
      '  FOffsetBitmap.Canvas.Brush.Color := Colors.Background;'
      '  FOffsetBitmap.Canvas.FillRect(Rect(0, 0, Width, Height));'
      '  ///'
      '  ///  and adjust the size of the "scaled down" version of full size bitmap'
      '  ///'
      '  LDrawHeight := Height;'
      '  if FOffsetBitmap.Height > LLineCount * FLineHeightInPixels then'
      '    LDrawheight := LLineCount * FLineHeightInPixels;'
      ''
      '  LDrawWidth := Trunc(FFullSizeBitmap.Width / FFontFactor);'
      ''
      '  FOffsetBitmap.Canvas.StretchDrawHalftone(0, 0, LDrawWidth, LDrawheight,'
      '    FFullSizeBitmap.Canvas, 0, 0, FFullSizeBitmap.Width, FFullSizeBitmap.Height);'
      ''
      '  ///'
      '  /// call paint to update the canvas'
      '  ///'
      '  Paint;'
      'end;'
      ''
      'procedure TSynMiniMap.ResetInternals;'
      'begin'
      '  if NOT Assigned(Editor) then'
      '    Exit;'
      '  FEditorHeight := Editor.Height;'
      '  FEditorWidth := Editor.Width;'
      '  FEditorRealWidth := FEditorWidth - Editor.Gutter.Width;'
      '  FFullSizeBitmap.Canvas.Brush.Style := bsSolid;'
      '  FFullSizeBitmap.Canvas.Brush.Color := Colors.Background;'
      '  FFullSizeBitmap.Canvas.Font.Height := Editor.Font.Height;'
      '  FFullSizeBitmap.Canvas.Font.Size := Editor.Font.Size;'
      '  FFullSizeBitmap.Canvas.Font.Name := Editor.Font.Name;'
      '  FCharWidth := FFullSizeBitmap.Canvas.TextWidth(''X'');'
      '  if Options.TabWidthOverride then'
      '    FTabWidth := Options.TabWidth'
      '  else'
      '    FTabWidth := FCharWidth * Editor.TabWidth;'
      '  FMaxCharsPerLine := Trunc(Self.Width / (FCharWidth / FFontFactor));'
      '  FFullSizeBitmap.Width := FMaxCharsPerLine * FCharWidth;'
      '  Self.Color := Editor.Color;'
      ''
      '  Render;'
      'end;'
      ''
      'procedure TSynMiniMap.Resize;'
      'const'
      '  CNO_EDITOR = ''(no editor assigned)'';'
      'var'
      '  LTextHeight: Integer;'
      '  LTextWidth: Integer;'
      '  LTextX: Integer;'
      '  LTextY: Integer;'
      'begin'
      '  FOffsetBitmap.Height := Self.Height;'
      '  FOffsetBitmap.Width := Self.Width;'
      '  FOffsetBitmap.Canvas.Brush.Color := Colors.Background;'
      '  FOffsetBitmap.Canvas.FillRect(Rect(0, 0, Width, Height));'
      '  FOffsetBitmap.Canvas.Font.Color := Colors.Text;'
      '  if csDesigning in ComponentState then begin'
      '    LTextHeight := FOffsetBitmap.Canvas.TextHeight(CNO_EDITOR);'
      '    LTextWidth := FOffsetBitmap.Canvas.TextWidth(CNO_EDITOR);'
      '    LTextX := Width div 2 - LTextWidth div 2;'
      '    LTextY := Height div 2 - LTextHeight div 2;'
      '    FOffsetBitmap.Canvas.TextOut(LTextX, LTextY, CNO_EDITOR);'
      '  end;'
      '  ResetInternals;'
      '  inherited Resize;'
      'end;'
      ''
      'procedure TSynMiniMap.SetEditor(const Value: TSynEdit);'
      'begin'
      '  FEditor := Value;'
      '  ///'
      '  ///  create a plugin if we don''t have one'
      '  ///'
      '  if Value <> NIL then'
      '    FMiniMapPlugin := TSynMiniMapEditorPlugin.Create(Self);'
      ''
      '  ResetInternals;'
      'end;'
      ''
      'procedure TSynMiniMap.SetFontFactor(const Value: Single);'
      'begin'
      '  if ( Value < SYNMINIMAP_FONTFACTOR_MIN ) or'
      '      ( Value > SYNMINIMAP_FONTFACTOR_MAX ) then begin'
      '    MessageDlg('
      '      Format(SFontFactorMinMax, [SYNMINIMAP_FONTFACTOR_MIN,'
      '        SYNMINIMAP_FONTFACTOR_MAX]),'
      '      mtError, [mbOK], 0);'
      '    Exit;'
      '  end;'
      '  FFontFactor := Value;'
      '  Render;'
      'end;'
      ''
      'procedure TSynMiniMap.SetPixelFormat(const Value: TPixelFormat);'
      'begin'
      '  ///'
      '  ///  set the pixel format on both bitmaps'
      '  ///'
      '  FFullSizeBitmap.PixelFormat := Value;'
      '  FOffsetBitmap.PixelFormat := Value;'
      'end;'
      ''
      'function TSynMiniMap.TranslatePoint(const APoint: PPoint): TBufferCoord;'
      'var'
      '  LChar: Integer;'
      'begin'
      '  ///'
      '  ///  this method translates X and Y from control''s surface into'
      '  ///  editor''s Line and Char, mainly used in OnClick event'
      '  ///'
      '  if APoint.X < 1 then'
      '    LChar := 1'
      '  else'
      '    LChar := Trunc(APoint.X / (FCharWidth / FFontFactor));'
      '  if LChar > FMaxCharsPerLine then'
      '    LChar := FMaxCharsPerLine;'
      '  Result.Char := LChar;'
      '  Result.Line := FFirstLine + APoint.Y div FLineHeightInPixels +1;'
      'end;'
      ''
      'initialization'
      ''
      'finalization'
      ''
      'end.'
    )
    ScrollBars = ssAutoHorizontal
    SelectedColor.FrameEdges = sfeAround
    SelectedColor.BackPriority = 50
    SelectedColor.ForePriority = 50
    SelectedColor.FramePriority = 50
    SelectedColor.BoldPriority = 50
    SelectedColor.ItalicPriority = 50
    SelectedColor.UnderlinePriority = 50
    SelectedColor.StrikeOutPriority = 50
    inline SynLeftGutterPartList1: TSynGutterPartList
      object SynGutterMarks1: TSynGutterMarks
        Width = 24
        MouseActions = <>
      end
      object SynGutterLineNumber1: TSynGutterLineNumber
        Width = 25
        MouseActions = <>
        MarkupInfo.Background = clBtnFace
        MarkupInfo.Foreground = clNone
        MarkupInfo.FrameEdges = sfeAround
        DigitCount = 2
        ShowOnlyLineNumbersMultiplesOf = 1
        ZeroStart = False
        LeadingZeros = False
      end
      object SynGutterChanges1: TSynGutterChanges
        Width = 4
        MouseActions = <>
        ModifiedColor = 59900
        SavedColor = clGreen
      end
      object SynGutterSeparator1: TSynGutterSeparator
        Width = 2
        MouseActions = <>
        MarkupInfo.Background = clWhite
        MarkupInfo.Foreground = clGray
        MarkupInfo.FrameEdges = sfeAround
      end
      object SynGutterCodeFolding1: TSynGutterCodeFolding
        MouseActions = <>
        MarkupInfo.Background = clNone
        MarkupInfo.Foreground = clGray
        MarkupInfo.FrameEdges = sfeAround
        MouseActionsExpanded = <>
        MouseActionsCollapsed = <>
      end
    end
  end
  object Panel: TPanel
    Left = 659
    Height = 404
    Top = 0
    Width = 170
    Align = alRight
    BevelOuter = bvNone
    Caption = 'Panel'
    ClientHeight = 404
    ClientWidth = 170
    TabOrder = 1
    object ScrollBar1: TScrollBar
      Left = 70
      Height = 17
      Top = 66
      Width = 121
      PageSize = 0
      TabOrder = 0
    end
  end
  object SynFreePascalSyn1: TSynFreePascalSyn
    Enabled = False
    AsmAttri.FrameEdges = sfeAround
    CommentAttri.FrameEdges = sfeAround
    IDEDirectiveAttri.FrameEdges = sfeAround
    IdentifierAttri.FrameEdges = sfeAround
    KeyAttri.FrameEdges = sfeAround
    NumberAttri.FrameEdges = sfeAround
    SpaceAttri.FrameEdges = sfeAround
    StringAttri.FrameEdges = sfeAround
    SymbolAttri.FrameEdges = sfeAround
    CaseLabelAttri.FrameEdges = sfeAround
    DirectiveAttri.FrameEdges = sfeAround
    CompilerMode = pcmObjFPC
    NestedComments = True
    left = 568
    top = 136
  end
  object MainMenu1: TMainMenu
    left = 560
    top = 88
    object MenuItem1: TMenuItem
      Caption = 'Отладка'
      object MenuItem2: TMenuItem
        Caption = 'Обновить миникарту'
        OnClick = MenuItem2Click
      end
    end
  end
end
